
<link rel="import" href="../../bower_components/polymer/polymer.html">

<dom-module id="htwg-swipe-menu">

  <template>
    <style>
    #sliderContainer {
    position: relative;
    border: solid;

    padding-top: 0px;
    padding-bottom: 0px;
    padding-right: 10px;
    padding-left: 10px;

    cursor: pointer;
    }
    </style>

    <div id="element-wrapper">
      <div id="sliderContainer" on-track="handleTrack" >
        <div id="sliderFrame">
          
        <content id="myContent"></content>

        </div>
      </div>
    </div>
  </template>

</dom-module>

<script>
  Polymer({
    is: 'htwg-swipe-menu',

    properties: {
      scrollable: {
        type: Boolean,
        value: false
      },

      //scroll direction
      horizontal: {
        type: Boolean,
        value: false
      },
      items: {
        type: Number
      },
      startY: Number
    },
    attached: function() {
      var distributed = this.getContentChildren('#myContent');
      this.items = distributed.length;
      for(i = 1; i <= distributed.length; i++){
        distributed[i-1].id = "hsm"+i;
      }
    },

	changeOpacity: function(element, opacity) {
        /*element.customStyle['--swipe-element-opacity'] = ""+opacity;
        element.updateStyles();*/
    },

    handleTrack: function(e) {

      var container_top = this.$.sliderContainer.getBoundingClientRect().top; 
      var container_bottom = this.$.sliderContainer.getBoundingClientRect().bottom;
      var container_mid_abs = (container_top + ((container_bottom - container_top) / 2));
      var sliderFrame = this.$.sliderFrame;
      var distributed = this.getContentChildren('#myContent');
      var sliderFrame_top = sliderFrame.getBoundingClientRect().top;
      var sliderFrame_bottom = sliderFrame.getBoundingClientRect().bottom;
      var sliderFrame_length = sliderFrame_bottom - sliderFrame_top;

      switch(e.detail.state) {
        case 'start':
          this.startY = e.detail.y;
          break;
        case 'track':
          for (i=1; i<=this.items; i++){
            var cObject = distributed[i-1];
            cObjectTop = cObject.getBoundingClientRect().top;
            cObjectBot = cObject.getBoundingClientRect().bottom;
            cObject.positionY= (e.detail.y - this.startY);

    			  this.changeOpacity(cObject, Math.abs(Math.sin((Math.PI / (container_bottom - container_top)) * (cObjectTop + cObject.positionY))));
    			  //console.log(Math.abs(Math.sin((Math.PI / (container_bottom - container_top)) * (cObjectTop + cObject.positionY))));
            
            //faehrt oben raus
            if (cObjectTop + cObject.positionY < container_top) {
              tmp = (this.startY - e.detail.y) - (cObjectTop - container_top);
              cObject.positionY = sliderFrame_length - tmp - i * (cObjectBot - cObjectTop);
             
              if((cObject.positionY < 5)) {
                this.startY = e.detail.y;
              }
            }
            
            //faehrt unten raus
            else if (cObjectBot +cObject.positionY > container_bottom) {
            	tmp = ( e.detail.y - this.startY) - (container_bottom - cObjectBot);
              cObject.positionY = (sliderFrame_length)  * (-1)  + tmp - ((this.items + 1) - i) * (cObjectTop - cObjectBot) ;
              if((cObject.positionY > -5)) {
                this.startY = e.detail.y;
              }
            }
          }

          break;

        case 'end':
          break;
      }

    }


  });
</script>